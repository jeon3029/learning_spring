# Spring MVC 구조

- 직접 만든 MVC 구조
![img1](./img/myspring_구조.png)

- Spring MVC 구조
![img1](./img/spring_구조.png)

사실상 이름 말고는 똑같은 구조이다.

## Spring MVC 전체 구조

### `DispatcherServlet` 구조 살펴보기

`org.springframework.web.servlet.DispatcherServlet`

- 프론트 컨트롤러 패턴으로 구현되어 있다.
- 디스패처 서블릿이 바로 스프링 MVC의 핵심
- `DispatcherServlet` 도 부모 클래스에서 HttpServlet 을 상속 받아서 사용하고, 서블릿으로 동작함
- `DispatcherServlet` 을 서블릿으로 자동으로 등록하면서 모든 경로( urlPatterns="/" )에 대해서 매핑
- 진짜 똑같나? 코드로 보자

`DispatcherServlet doDispatch()`

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse
  response) throws Exception {
  HttpServletRequest processedRequest = request;
  HandlerExecutionChain mappedHandler = null;
  ModelAndView mv = null;
  // 1. 핸들러 조회
  mappedHandler = getHandler(processedRequest); if (mappedHandler == null) {
    noHandlerFound(processedRequest, response);
    return; 
  }
  //2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터
  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
  // 3. 핸들러 어댑터 실행 -> 4. 핸들러 어댑터를 통해 핸들러 실행 -> 5. ModelAndView 반환 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
}
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {
// 뷰 렌더링 호출
  render(mv, request, response);
}
protected void render(ModelAndView mv, HttpServletRequest request,
HttpServletResponse response) throws Exception {
  View view;
  String viewName = mv.getViewName(); //6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환
  view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
  // 8. 뷰 렌더링
  view.render(mv.getModelInternal(), request, response);
}
```

### 동작 순서

- Spring MVC 구조
![img3](./img/spring_구조2.png)

1. 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. 핸들러 어댑터 실행: 핸들러 어댑터를 실행한다.
4. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.
5. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
6. viewResolver 호출: 뷰 리졸버를 찾고 실행한다.
   - JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.
7. View반환:뷰리졸버는 뷰의 논리이름을 물리이름으로 바꾸고,렌더링역할을 담당하는 뷰객체를 반환한다.
   - JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.
8. 뷰렌더링: 뷰를 통해서 뷰를 렌더링한다.

### 주요 인터페이스

- 핸들러 매핑: org.springframework.web.servlet.HandlerMapping
- 핸들러 어댑터: org.springframework.web.servlet.HandlerAdapter
- 뷰 리졸버: org.springframework.web.servlet.ViewResolver
- 뷰: org.springframework.web.servlet.View

### 정리

- 내부구조를 모두 파악하는것은 쉽지 않지만, 핵심 로직은 단순하다. 전체적인 구조를 이해하자.
- 확장포인트 필요할 때, 문제가 났을 때 도움이 될 것이다.

## 핸들러 매핑과 핸들러

지금은 전혀 사용하지 않지만, 과거에 주로 사용했던 스프링이 제공하는 간단한 컨트롤러로 핸들러 매핑과 어댑터를 이해해보자

- 과거버전 스프링 컨트롤러
- `org.springframework.web.servlet.mvc.Controller`

```java
public interface Controller {
    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse
  response) throws Exception;
}
```

> 현재 사용하는 `@Controller` 와는 전혀 다르다.

- [OldController](./servlet/src/main/java/hello/servlet/web/springmvc/old/OldController.java)
  - <http://localhost:8080/springmvc/old-controller>
  - 이 컨트롤러는 어떻게 호출되는 것일까?
  - 컨트롤러가 호출되려면
    - HandlerMapping(핸들러 매핑)
      - 핸들러 매핑에서 이 컨트롤러를 찾을 수 있어야 한다.
      - 예) 스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요하다.  
    - HandlerAdapter(핸들러 어댑터)
      - 핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요하다.
      - 예) Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 한다

- 스프링 부트가 자동 등록하는 핸들러 매핑과 핸들러 어댑터
  - HandlerMapping
    - 0 = RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
    - 1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다.
  - HandlerAdapter
    - 0 = RequestMappingHandlerAdapter : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
    - 1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리
    - 2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리
- 지금 경우에는 1,2
  - HandlerMapping = BeanNameUrlHandlerMapping
  - HandlerAdapter = SimpleControllerHandlerAdapter

### HttpRequestHandler

`HttpRequestHandler핸들러(컨트롤러)`는 서블릿과 가장 유사한 형태의 핸들러이다.

```java
public interface HttpRequestHandler {
  void handleRequest(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException;
}
```

- [MyHttpRequestHandler](./servlet/src/main/java/hello/servlet/web/springmvc/old/MyHttpRequestHandler.java)
  - <http://localhost:8080/springmvc/request-handler>
- 지금 경우에는 1,1
  - HandlerMapping = BeanNameUrlHandlerMapping
  - HandlerAdapter = HttpRequestHandlerAdapter

> `@RequestMapping`
> 가장 우선순위가 높은 핸들러 매핑과 핸들러 어댑터는 `RequestMappingHandlerMapping` ,`RequestMappingHandlerAdapter` 이다
> 실무에서는 99.9% 이 방식의 컨트롤러를 사용한다.

## 뷰 리졸버

기존 `OldController` 변경

[OldController](./servlet/src/main/java/hello/servlet/web/springmvc/old/OldController.java)

```java
return new ModelAndView("new-form");
```

`application.properties` 에 코드 추가

```properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

- 스프링 부트는 `InternalResourceViewResolver` 라는 뷰 리졸버를 자동으로 등록하는데, 이때 application.properties 에 등록한 `spring.mvc.view.prefix` , `spring.mvc.view.suffix` 설정 정보를 사용해서 등록한다
  ```java
  return new ModelAndView("/WEB-INF/views/new-form.jsp");
  ```
  - 다음과 같이 리턴해도 동작함.

- 동작 확인
<http://localhost:8080/springmvc/old-controller>

### 스프링부트가 자동등록하는 뷰 리졸버

```text
1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성 기능에 사용)
2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.
```

- 호출 순서
  1. InternalResourceViewResolver
  2. InternalResourceView 반환
  3. view.render()
  4. forward() -> jsp 실행
    - jsp 제외한 나머지 뷰 템플릿은 forward() 과정 없음