= 04.Entity Mapping
:reproducible:
:listing-caption: Source
:source-highlighter: rouge
:toc:
:hardbreaks:
:image-url1: https://cdn.jsdelivr.net/gh/jeon3029/learning_spring@master/jpa_basic/img/img4_1.png
:image-url2: https://cdn.jsdelivr.net/gh/jeon3029/learning_spring@master/jpa_basic/img/img4_2.png

== 엔티티 매핑

.매핑 속성 정리
객체와 테이블 매핑: @Entity, @Table
필드와 컬럼 매핑: @Colum
기본 키 매핑: @Id
연관관계 매핑: @ManyToOne,@JoinColumn

=== Entity

* Entity 가 붙은 클래스는 JPA 가 관리한다.
** 기본 생성자 필수
** 저장할 필드에 final 사용 x

== 데이터베이스 스키마 자동생성 속성

.persistence.xml
[source,xml]
----
<property name="hibernate.hbm2ddl.auto" value="create" />
----
[options="header"]
|===============================================
| 옵션          | 설명                              
| create      | 기존테이블 삭제 후 다시 생성 (DROP + CREATE)
| create-drop | create와 같으나 종료시점에 테이블 DROP      
| update      | 변경분만 반영(운영DB에는 사용하면 안됨)         
| validate    | 엔티티와 테이블이 정상 매핑되었는지만 확인         
| none        | 사용하지 않음                         
|===============================================

WARNING: 운영 장비에는 절대 create, create-drop, update 사용하면 안된다.

====
* 개발 초기 단계는 create 또는 update 
* 테스트 서버는 update 또는 validate
* 스테이징과 운영 서버는 validate 또는 none
====


=== DDL 생성기능

[source,java]
----
@Column(nullable = false, length = 10)

@Table(uniqueConstraints = {@UniqueConstraint( name ="NAME_AGE_UNIQUE", columnNames = {"NAME", "AGE"} )})
----

DDL 생성기능은 자동생성할 때만 사용. JPA의 실행 로직에는 영향을 주지 않는다

=== 필드와 컬럼 매핑

요구사항을 구현하면서 실습해보자

. 회원은 일반회원과 관리자로 구분해야한다.
. 회원가입일과 수정일이 있어야한다.
. 회원을 설명할 수 있는 필드가 있어야한다. 
.. 이 필드는 길이 제한이 없다.

.Member.java
[source,java]
----
@Entity
public class Member {
  @Id
  private Long id;

  @Column(name = "name")
  private String username;
  
  private Integer age;
  
  @Enumerated(EnumType.STRING)
  private RoleType roleType;
  
  @Temporal(TemporalType.TIMESTAMP)
  private Date createdDate;
  
  @Temporal(TemporalType.TIMESTAMP)
  private Date lastModifiedDate;
  
  @Lob
  private String description;

  public Member(){

  }
}
----

.자동으로 생성된 sql
[source,sh]
----
create table Member (
       id bigint not null,
        age integer,
        createdDate timestamp,
        description clob,
        lastModifiedDate timestamp,
        roleType varchar(255),
        name varchar(255),
        primary key (id)
    )
----

.Mapping Annotation
[options="header"]
|========================================
| Annotation  | 설명                       
| @Column     | 컬럼 매핑                    
| @Temporal   | 날짜 타입 매핑                 
| @Enumerated | enum 타입 매핑               
| @Lob        | BLOB/CLOB 매핑             
| @Transient  | 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)
|========================================

.Column
[options="header"]
|===
|속성 |설명 |기본값
|name
|필드와 매핑할 테이블의 컬럼 이름
|객체의 필드 이름
|insertable/updatable
|등록/변경 가능 여부
|TRUE
|nullable(DDL)
|null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.
|
|unique(DDL)
|@Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다.
|
|columnDefinition (DDL)
|데이터베이스 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default ‘EMPTY'
|필드의 자바 타입과 방언 정보 사용해서 적절한 컬럼 타입 적용
|length(DDL)
|문자 길이 제약조건/String 타입에만 사용한다
|255
|precision/scale(DDL)
|BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다). precision은 소수점을 포함한 전체 자 릿수를 scale은 소수의 자릿수 다. 참고로 double/float 타입에는 적용되지 않는다. 아주 큰 숫자나 정 밀한 소수를 다루어야 할 때만 사용한다.
|precision=19/scale=2
|===

.@Enumerated

. EnumType.ORDINAL: enum 순서를 데이터베이스에 저장
. EnumType.STRING: enum 이름을 데이터베이스에 저장
주의! ORDINAL 사용X

.@Temporal

> 참고: LocalDate, LocalDateTime을 사용할 때는 생략 가능

. TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑 (예: 2013–10–11)
. TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11)
. TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)


== 기본키 매핑

[source,java]
----
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
----

.매핑 방법
* 직접 할당: @Id만 사용
* 자동 생성(@GeneratedValue)
** IDENTITY: 데이터베이스에 위임, MYSQL
+
[source,sh]
----
    create table Member (
       id bigint generated by default as identity,
        username varchar(255),
        primary key (id)
    )
----
*** AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음
*** IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행 하고 DB에서 식별자를 조회
** SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
+
[source,sh]
----
create sequence hibernate_sequence start with 1 increment by 1
#...
create table Member (
      id bigint not null,
      username varchar(255),
)      

#...
call next value for hibernate_sequence
----

*** @SequenceGenerator 필요
+
[options="header"]
|===
|속성 |설명 |기본값 
|name
|식별자 생성기 이름
|필수
|sequenceName
|데이터베이스에 등록되어 있는 시퀀스 이름
|hibernate_sequence
|initialValue
|DDL 생성 시에만 사용됨 / 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다.
|1
|allocationSize
|시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값 을 반드시 1로 설정해야 한다
|50
|catalog/ schema
|데이터베이스 catalog/ schema 이름
|
|===
** TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
*** @TableGenerator 필요
+
[source,java]
----
create table MY_SEQUENCES (
  sequence_name varchar(255) not null,
  next_val bigint,
  primary key ( sequence_name )
)
//////////////
@Entity
@TableGenerator(
name = "MEMBER_SEQ_GENERATOR",
table = "MY_SEQUENCES",
pkColumnValue = "MEMBER_SEQ", allocationSize = 1)
public class Member {
  @Id
  @GeneratedValue(strategy = GenerationType.TABLE,
  generator = "MEMBER_SEQ_GENERATOR")
  private Long id;
  //....
}
----
+
.TableGenerator 속성
[options="header"]
|===
|속성 |설명 |기본값
|name
|식별자 생성기 이름
|필수
|table
|키생성 테이블명
|hibernate_sequences
|pkColumnName
|시퀀스 컬럼명
|sequence_name
|valueColumnNa
|시퀀스 값 컬럼명
|next_val
|pkColumnValue
|키로 사용할 값 이름
|엔티티 이름
|initialValue
|초기 값/ 마지막으로 생성된 값이 기준이다.
|0
|allocationSize
|시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)
|50
|catalog/ schema
|데이터베이스 catalog/ schema 이름
|
|uniqueConstraint s(DDL)
|유니크 제약 조건을 지정할 수 있다.
|
|===
** AUTO: 방언에 따라 자동 지정, 기본값

.권장하는 키 생성 전략
. 기본 키 제약 조건: null 아님, 유일, 변하면 안된다.
. 권장: Long형 + 대체키 + 키 생성전략 사용

== 실전 예제: 요구사항 분석과 기본 매핑

. 회원은 상품을 주문할 수 있다.
. 주문시여러종류의상품을선택할수있다.
====
.기능목록
. 회원기능
.. 회원등록
.. 회원조회 
. 상품기능
.. 상품등록
.. 상품수정
.. 상품조회
. 주문기능
.. 상품주문
.. 주문내역조회
.. 주문취소
====

.테이블 설계
image::{image-url1}[]
.엔티티 설계
image::{image-url2}[]

.현재 방식은 객체 설계를 테이블 설계에 맞춘 방식
* 테이블의 외래키를 객체에 그대로 가져옴
* 객체 그래프 탐색이 불가능 
* 참조가 없으므로 UML도 잘못됨